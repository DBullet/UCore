## 段寄存器的字段含义和功能有哪些？

在保护模式下，段寄存器中保存着段选择子。段选择子的高13位是描述符索引(Index)。描述符索引是指描述符在描述符表中的序号。段选择子的第2位是引用描述符表指示位，标记为TI(Table Indicator)，TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。选择子的最低两位是请求特权级RPL(Requested Privilege Level)，用于特权检查。

## 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？

DPL描述符特权级，保存在段描述符中，表示访问该段所需要的特权级。CPL当前特权级，保存在CS，SS寄存器的最低两位，表示当前CPU运行状态下所处的特权级。RPL请求特权级保存在对应的段寄存器中，表示以何种特权级对该段寄存器中的段选择子所选中的段描述符进行访问。成功访问的条件是max {CPL, RPL} <= DPL。

## 中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

发生中断时，硬件会把被中断进程的下一条指令和EFLAG压入内核栈，如果发生了用户态到内核态的转换，硬件还将把CS，SS寄存器的内容压栈。

## 为什么在用户态的中断响应要使用内核堆栈？

因为对应的中断处理例程在内核中，需要ring0特权级。在用户态的中断响应必须发生特权级的转换，并调入内核代码执行。

## trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?

interrupt中断门，在转移过程中把IF置为0，使得在处理程序执行期间屏蔽掉中断，对于trap中断门，在转移过程中保持IF位不变，即如果IF位原来是1，那么通过陷阱门转移到处理程序之后仍允许INTR中断。如果不作区分，在执行中断服务例程的时候可能会发生中断嵌套。

## 在kdebug.c文件中用到的函数r`ead_ebp`是内联的，而函数r`ead_eip`不是内联的。为什么要设计成这样？

因为若不内联，函数调用将会有新的过程调用使得ebp的值被修改。相反，eip寄存器的值无法通过一般指令直接访问，需要通过一个无参函数来简介访问。

## CPU加电初始化后中断是使能的吗？为什么？

不是。因为初始化的过程不能被中断打扰，且初始化时操作系统内核还未被加载运行，CPU也无法执行中断服务例程。